{"version":3,"sources":["Hooks/recorderHelpers.js","Hooks/recorder.js","Hooks/index.tsx","mic.svg","App.tsx","index.js"],"names":["microphoneStream","input","Recorder","source","cfg","_this","_classCallCheck","this","config","_objectSpread","bufferLen","numChannels","mimeType","recording","callbacks","getBuffer","exportWAV","context","node","createScriptProcessor","createJavaScriptNode","call","onaudioprocess","e","buffer","channel","push","inputBuffer","getChannelData","worker","postMessage","command","connect","destination","InlineWorker","sampleRate","newSampleRate","recLength","recBuffers","initBuffers","mergeBuffers","result","Float32Array","offset","i","length","set","writeString","view","string","setUint8","charCodeAt","onmessage","data","record","type","interleaved","buffers","inputL","inputR","index","inputIndex","interleave","dataview","samples","ArrayBuffer","DataView","setUint32","setUint16","output","s","Math","max","min","setInt16","floatTo16BitPCM","encodeWAV","rate","sampleRateRatio","newLength","round","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","downSampleBuffer","audioBlob","Blob","cb","pop","_createClass","key","value","callback","Error","blob","filename","url","window","URL","webkitURL","createObjectURL","link","document","createElement","href","download","click","createEvent","initEvent","dispatchEvent","rec","startRecording","_x","_startRecording","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_ref","audioContext","errHandler","onStreamLoad","stream","wrap","_context","prev","next","navigator","mediaDevices","getUserMedia","audio","sent","createMediaStreamSource","abrupt","t0","console","log","stop","stopRecording","_ref2","wavCallback","getAudioTracks","clear","recognition","isEdgeChromium","userAgent","indexOf","AudioContext","webkitAudioContext","SpeechRecognition","webkitSpeechRecognition","brave","isBrave","then","bool","App","_useSpeechToText","continuous","crossBrowser","googleApiKey","googleCloudRecognitionConfig","onStartSpeaking","onStoppedSpeaking","_ref$speechRecognitio","speechRecognitionProperties","interimResults","lang","_ref$timeout","timeout","_ref$useOnlyGoogleClo","useOnlyGoogleCloud","_ref$useLegacyResults","useLegacyResults","_useState","useState","_useState2","_slicedToArray","isRecording","setIsRecording","audioContextRef","useRef","_useState3","_useState4","legacyResults","setLegacyResults","_useState5","_useState6","results","setResults","_useState7","_useState8","interimResult","setInterimResult","_useState9","_useState10","error","setError","timeoutId","mediaStream","useEffect","_navigator","_navigator$mediaDevic","current","warn","chromeSpeechRecognition","grammars","maxAlternatives","start","onresult","transcript","timestamp","floor","Date","now","isFinal","undefined","prevResults","concat","_toConsumableArray","concatTranscripts","resultIndex","onaudiostart","onend","startSpeechToText","_ref3","_audioContextRef$curr","_audioContextRef$curr2","speechEvents","state","resume","clearTimeout","handleRecordingTimeout","stopMediaStream","clone","Hark","on","handleBlobToBase64","setTimeout","_ref4","reader","FileReader","readAsDataURL","onloadend","_callee2","_audioContextRef$curr3","_googleCloudJson$resu","base64data","googleCloudRes","googleCloudJson","_context2","content","encoding","languageCode","sampleRateHertz","substr","fetch","method","body","JSON","stringify","json","alternatives","speechBlob","_mediaStream$current","stopSpeechToText","useSpeechToText","process","REACT_APP_API_KEY","_jsx","style","maxWidth","margin","textAlign","children","_jsxs","fontSize","toString","onClick","src","micIcon","alt","map","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.20e511d6.chunk.js","sourcesContent":["import Recorder from './recorder';\n\nlet microphoneStream; // stream from getUserMedia()\nlet rec = Recorder; // Recorder.js object\nlet input; // MediaStreamAudioSourceNode we'll be recording\n\n/**\n *\n * @param {{\n * audioContext: AudioContext\n * errHandler?: () => void\n * onStreamLoad?: () => void\n * }}\n * @returns {Promise<MediaStream>}\n */\nexport async function startRecording({\n  audioContext,\n  errHandler,\n  onStreamLoad,\n}) {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n\n    if (onStreamLoad) {\n      onStreamLoad();\n    }\n\n    /*  assign stream for later use  */\n    microphoneStream = stream;\n\n    /* use the stream */\n    input = audioContext.createMediaStreamSource(stream);\n\n    rec = new Recorder(input);\n\n    // start the recording process\n    rec.record();\n\n    return stream;\n  } catch (err) {\n    console.log(err);\n\n    if (errHandler) {\n      errHandler();\n    }\n  }\n}\n\n/**\n *\n * @param {{\n * exportWAV: boolean\n * wavCallback?: (blob: Blob) => void\n * }}\n */\nexport function stopRecording({ exportWAV, wavCallback }) {\n  // stop recorder.js recording\n  rec.stop();\n\n  // stop microphone access\n  microphoneStream.getAudioTracks()[0].stop();\n\n  // create the wav blob\n  if (exportWAV && wavCallback) {\n    rec.exportWAV((blob) => wavCallback(blob));\n  }\n\n  rec.clear();\n}\n","import InlineWorker from 'inline-worker';\n\nexport class Recorder {\n  constructor(source, cfg) {\n    this.config = {\n      bufferLen: 4096,\n      numChannels: 1,\n      mimeType: 'audio/wav',\n      ...cfg\n    };\n    this.recording = false;\n    this.callbacks = {\n      getBuffer: [],\n      exportWAV: []\n    };\n    this.context = source.context;\n    this.node = (\n      this.context.createScriptProcessor || this.context.createJavaScriptNode\n    ).call(\n      this.context,\n      this.config.bufferLen,\n      this.config.numChannels,\n      this.config.numChannels\n    );\n\n    this.node.onaudioprocess = (e) => {\n      if (!this.recording) return;\n\n      var buffer = [];\n      for (var channel = 0; channel < this.config.numChannels; channel++) {\n        buffer.push(e.inputBuffer.getChannelData(channel));\n      }\n      this.worker.postMessage({\n        command: 'record',\n        buffer: buffer\n      });\n    };\n\n    source.connect(this.node);\n    this.node.connect(this.context.destination); //this should not be necessary\n\n    let self = {};\n    this.worker = new InlineWorker(function () {\n      let recLength = 0,\n        recBuffers = [],\n        sampleRate,\n        numChannels;\n\n      this.onmessage = function (e) {\n        switch (e.data.command) {\n          case 'init':\n            init(e.data.config);\n            break;\n          case 'record':\n            record(e.data.buffer);\n            break;\n          case 'exportWAV':\n            exportWAV(e.data.type);\n            break;\n          case 'getBuffer':\n            getBuffer();\n            break;\n          case 'clear':\n            clear();\n            break;\n        }\n      };\n\n      let newSampleRate;\n\n      function init(config) {\n        sampleRate = config.sampleRate;\n        numChannels = config.numChannels;\n        initBuffers();\n\n        if (sampleRate > 48000) {\n          newSampleRate = 48000;\n        } else {\n          newSampleRate = sampleRate;\n        }\n      }\n\n      function record(inputBuffer) {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel].push(inputBuffer[channel]);\n        }\n        recLength += inputBuffer[0].length;\n      }\n\n      function exportWAV(type) {\n        let buffers = [];\n        for (let channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n        let interleaved;\n        if (numChannels === 2) {\n          interleaved = interleave(buffers[0], buffers[1]);\n        } else {\n          interleaved = buffers[0];\n        }\n\n        // converts sample rate to 48000 if higher than 48000\n        let downSampledBuffer = downSampleBuffer(interleaved, newSampleRate);\n\n        let dataview = encodeWAV(downSampledBuffer);\n        let audioBlob = new Blob([dataview], { type: type });\n\n        this.postMessage({ command: 'exportWAV', data: audioBlob });\n      }\n\n      function getBuffer() {\n        let buffers = [];\n        for (let channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n        this.postMessage({ command: 'getBuffer', data: buffers });\n      }\n\n      function clear() {\n        recLength = 0;\n        recBuffers = [];\n        initBuffers();\n      }\n\n      function initBuffers() {\n        for (let channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel] = [];\n        }\n      }\n\n      function mergeBuffers(recBuffers, recLength) {\n        let result = new Float32Array(recLength);\n        let offset = 0;\n        for (let i = 0; i < recBuffers.length; i++) {\n          result.set(recBuffers[i], offset);\n          offset += recBuffers[i].length;\n        }\n        return result;\n      }\n\n      function interleave(inputL, inputR) {\n        let length = inputL.length + inputR.length;\n        let result = new Float32Array(length);\n\n        let index = 0,\n          inputIndex = 0;\n\n        while (index < length) {\n          result[index++] = inputL[inputIndex];\n          result[index++] = inputR[inputIndex];\n          inputIndex++;\n        }\n        return result;\n      }\n\n      function floatTo16BitPCM(output, offset, input) {\n        for (let i = 0; i < input.length; i++, offset += 2) {\n          let s = Math.max(-1, Math.min(1, input[i]));\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n        }\n      }\n\n      function writeString(view, offset, string) {\n        for (let i = 0; i < string.length; i++) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      }\n\n      // Down sample buffer before WAV encoding\n      function downSampleBuffer(buffer, rate) {\n        if (rate == sampleRate) {\n          return buffer;\n        }\n        if (rate > sampleRate) {\n          throw 'downsampling rate show be smaller than original sample rate';\n        }\n        var sampleRateRatio = sampleRate / rate;\n        var newLength = Math.round(buffer.length / sampleRateRatio);\n        var result = new Float32Array(newLength);\n        var offsetResult = 0;\n        var offsetBuffer = 0;\n        while (offsetResult < result.length) {\n          var nextOffsetBuffer = Math.round(\n            (offsetResult + 1) * sampleRateRatio\n          );\n          // Use average value of skipped samples\n          var accum = 0,\n            count = 0;\n          for (\n            var i = offsetBuffer;\n            i < nextOffsetBuffer && i < buffer.length;\n            i++\n          ) {\n            accum += buffer[i];\n            count++;\n          }\n          result[offsetResult] = accum / count;\n          // Or you can simply get rid of the skipped samples:\n          // result[offsetResult] = buffer[nextOffsetBuffer];\n          offsetResult++;\n          offsetBuffer = nextOffsetBuffer;\n        }\n        return result;\n      }\n\n      function encodeWAV(samples) {\n        let buffer = new ArrayBuffer(44 + samples.length * 2);\n        let view = new DataView(buffer);\n\n        /* RIFF identifier */\n        writeString(view, 0, 'RIFF');\n        /* RIFF chunk length */\n        view.setUint32(4, 36 + samples.length * 2, true);\n        /* RIFF type */\n        writeString(view, 8, 'WAVE');\n        /* format chunk identifier */\n        writeString(view, 12, 'fmt ');\n        /* format chunk length */\n        view.setUint32(16, 16, true);\n        /* sample format (raw) */\n        view.setUint16(20, 1, true);\n        /* channel count */\n        view.setUint16(22, numChannels, true);\n        /* sample rate */\n        view.setUint32(24, newSampleRate, true);\n        /* byte rate (sample rate * block align) */\n        view.setUint32(28, newSampleRate * 4, true);\n        /* block align (channel count * bytes per sample) */\n        view.setUint16(32, numChannels * 2, true);\n        /* bits per sample */\n        view.setUint16(34, 16, true);\n        /* data chunk identifier */\n        writeString(view, 36, 'data');\n        /* data chunk length */\n        view.setUint32(40, samples.length * 2, true);\n\n        floatTo16BitPCM(view, 44, samples);\n\n        return view;\n      }\n    }, self);\n\n    this.worker.postMessage({\n      command: 'init',\n      config: {\n        sampleRate: this.context.sampleRate,\n        numChannels: this.config.numChannels\n      }\n    });\n\n    this.worker.onmessage = (e) => {\n      let cb = this.callbacks[e.data.command].pop();\n      if (typeof cb == 'function') {\n        cb(e.data.data);\n      }\n    };\n  }\n\n  record() {\n    this.recording = true;\n  }\n\n  stop() {\n    this.recording = false;\n  }\n\n  clear() {\n    this.worker.postMessage({ command: 'clear' });\n  }\n\n  getBuffer(cb) {\n    cb = cb || this.config.callback;\n    if (!cb) throw new Error('Callback not set');\n\n    this.callbacks.getBuffer.push(cb);\n\n    this.worker.postMessage({ command: 'getBuffer' });\n  }\n\n  exportWAV(cb, mimeType) {\n    mimeType = mimeType || this.config.mimeType;\n    cb = cb || this.config.callback;\n    if (!cb) throw new Error('Callback not set');\n\n    this.callbacks.exportWAV.push(cb);\n\n    this.worker.postMessage({\n      command: 'exportWAV',\n      type: mimeType\n    });\n  }\n\n  static forceDownload(blob, filename) {\n    let url = (window.URL || window.webkitURL).createObjectURL(blob);\n    let link = window.document.createElement('a');\n    link.href = url;\n    link.download = filename || 'output.wav';\n    let click = document.createEvent('Event');\n    click.initEvent('click', true, true);\n    link.dispatchEvent(click);\n  }\n}\n\nexport default Recorder;\n","import { useState, useEffect, useRef } from 'react';\nimport Hark from 'hark';\nimport { startRecording, stopRecording } from './recorderHelpers';\n\n// https://cloud.google.com/speech-to-text/docs/reference/rest/v1/RecognitionConfig\nimport { GoogleCloudRecognitionConfig } from './GoogleCloudRecognitionConfig';\n\n// https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition\nexport interface SpeechRecognitionProperties {\n  // continuous: do not pass continuous here, instead pass it as a param to the hook\n  grammars?: any;\n  interimResults?: boolean;\n  lang?: string;\n  maxAlternatives?: number;\n}\n\nconst isEdgeChromium = navigator.userAgent.indexOf('Edg/') !== -1;\n\ninterface BraveNavigator extends Navigator {\n  brave: {\n    isBrave: () => Promise<boolean>;\n  };\n}\n\nconst AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n// @ts-ignore\nconst SpeechRecognition = window.SpeechRecognition || (window as any).webkitSpeechRecognition;\n// @ts-ignore\nlet recognition: SpeechRecognition | null;\n\nexport type ResultType = {\n  speechBlob?: Blob;\n  timestamp: number;\n  transcript: string;\n};\n\n// Set recognition back to null for brave browser due to promise resolving\n// after the conditional on line 31\nif ((navigator as BraveNavigator).brave) {\n  (navigator as BraveNavigator).brave.isBrave().then((bool) => {\n    if (bool) recognition = null;\n  });\n}\n\n// Chromium browsers will have the SpeechRecognition method\n// but do not implement the functionality due to google wanting üí∞\n// this covers new Edge and line 22 covers Brave, the two most popular non-chrome chromium browsers\nif (!isEdgeChromium && SpeechRecognition) {\n  recognition = new SpeechRecognition();\n}\n\nexport interface UseSpeechToTextTypes {\n  continuous?: boolean;\n  crossBrowser?: boolean;\n  googleApiKey?: string;\n  googleCloudRecognitionConfig?: GoogleCloudRecognitionConfig;\n  onStartSpeaking?: () => any;\n  onStoppedSpeaking?: () => any;\n  speechRecognitionProperties?: SpeechRecognitionProperties;\n  timeout?: number;\n  useLegacyResults?: boolean;\n  useOnlyGoogleCloud?: boolean;\n}\n\nexport default function useSpeechToText({\n  continuous,\n  crossBrowser,\n  googleApiKey,\n  googleCloudRecognitionConfig,\n  onStartSpeaking,\n  onStoppedSpeaking,\n  speechRecognitionProperties = { interimResults: true, lang: 'en-US' },\n  timeout = 10000,\n  useOnlyGoogleCloud = false,\n  useLegacyResults = true\n}: UseSpeechToTextTypes) {\n  const [isRecording, setIsRecording] = useState(false);\n\n  const audioContextRef = useRef<AudioContext>();\n\n  const [legacyResults, setLegacyResults] = useState<string[]>([]);\n  const [results, setResults] = useState<ResultType[]>([]);\n\n  const [interimResult, setInterimResult] = useState<string | undefined>();\n  const [error, setError] = useState('');\n\n  const timeoutId = useRef<number>();\n  const mediaStream = useRef<MediaStream>();\n\n  useEffect(() => {\n    if (!crossBrowser && !recognition) {\n      setError('Speech Recognition API is only available on Chrome');\n    }\n\n    if (!navigator?.mediaDevices?.getUserMedia) {\n      setError('getUserMedia is not supported on this device/browser :(');\n    }\n\n    if ((crossBrowser || useOnlyGoogleCloud) && !googleApiKey) {\n      console.error(\n        'No google cloud API key was passed, google API will not be able to process speech'\n      );\n    }\n\n    if (!audioContextRef.current) {\n      audioContextRef.current = new AudioContext();\n    }\n\n    if (useLegacyResults) {\n      console.warn(\n        'react-hook-speech-to-text is using legacy results, pass useLegacyResults: false to the hook to use the new array of objects results. Legacy array of strings results will be removed in a future version.'\n      );\n    }\n  }, []);\n\n  // Chrome Speech Recognition API:\n  // Only supported on Chrome browsers\n  const chromeSpeechRecognition = () => {\n    if (recognition) {\n      // Continuous recording after stopped speaking event\n      if (continuous) recognition.continuous = true;\n\n      const { grammars, interimResults, lang, maxAlternatives } =\n        speechRecognitionProperties || {};\n\n      if (grammars) recognition.grammars = grammars;\n      if (lang) recognition.lang = lang;\n\n      recognition.interimResults = interimResults || false;\n      recognition.maxAlternatives = maxAlternatives || 1;\n\n      // start recognition\n      recognition.start();\n\n      // speech successfully translated into text\n      recognition.onresult = (e: any) => {\n        const result = e.results[e.results.length - 1];\n        const { transcript } = result[0];\n\n        const timestamp = Math.floor(Date.now() / 1000);\n\n        // Allows for realtime speech result UI feedback\n        if (interimResults) {\n          if (result.isFinal) {\n            setInterimResult(undefined);\n            setResults((prevResults) => [\n              ...prevResults,\n              { transcript, timestamp }\n            ]);\n            setLegacyResults((prevResults) => [...prevResults, transcript]);\n          } else {\n            let concatTranscripts = '';\n\n            // If continuous: e.results will include previous speech results: need to start loop at the current event resultIndex for proper concatenation\n            for (let i = e.resultIndex; i < e.results.length; i++) {\n              concatTranscripts += e.results[i][0].transcript;\n            }\n\n            setInterimResult(concatTranscripts);\n          }\n        } else {\n          setResults((prevResults) => [\n            ...prevResults,\n            { transcript, timestamp }\n          ]);\n          setLegacyResults((prevResults) => [...prevResults, transcript]);\n        }\n      };\n\n      recognition.onaudiostart = () => setIsRecording(true);\n\n      // Audio stopped recording or timed out.\n      // Chrome speech auto times-out if no speech after a while\n      recognition.onend = () => {\n        setIsRecording(false);\n      };\n    }\n  };\n\n  const startSpeechToText = async () => {\n    if (!useOnlyGoogleCloud && recognition) {\n      chromeSpeechRecognition();\n      return;\n    }\n\n    if (!crossBrowser && !useOnlyGoogleCloud) {\n      return;\n    }\n\n    // Resume audio context due to google auto play policy\n    // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio\n    if (audioContextRef.current?.state === 'suspended') {\n      audioContextRef.current?.resume();\n    }\n\n    const stream = await startRecording({\n      errHandler: () => setError('Microphone permission was denied'),\n      audioContext: audioContextRef.current as AudioContext\n    });\n\n    setIsRecording(true);\n\n    // Stop recording if timeout\n    if (timeout) {\n      clearTimeout(timeoutId.current);\n      handleRecordingTimeout();\n    }\n\n    // stop previous mediaStream track if exists\n    if (mediaStream.current) {\n      stopMediaStream();\n    }\n\n    // Clones stream to fix hark bug on Safari\n    mediaStream.current = stream.clone();\n\n    const speechEvents = Hark(mediaStream.current, {\n      audioContext: audioContextRef.current as AudioContext\n    });\n\n    speechEvents.on('speaking', () => {\n      if (onStartSpeaking) onStartSpeaking();\n\n      // Clear previous recording timeout on every speech event\n      clearTimeout(timeoutId.current);\n    });\n\n    speechEvents.on('stopped_speaking', () => {\n      if (onStoppedSpeaking) onStoppedSpeaking();\n\n      // Stops current recording and sends audio string to google cloud.\n      // recording will start again after google cloud api\n      // call if `continuous` prop is true. Until the api result\n      // returns, technically the microphone is not being captured again\n      stopRecording({\n        exportWAV: true,\n        wavCallback: (blob) =>\n          handleBlobToBase64({ blob, continuous: continuous || false })\n      });\n    });\n  };\n\n  const stopSpeechToText = () => {\n    if (recognition && !useOnlyGoogleCloud) {\n      recognition.stop();\n    } else {\n      setIsRecording(false);\n      stopMediaStream();\n      stopRecording({\n        exportWAV: true,\n        wavCallback: (blob) => handleBlobToBase64({ blob, continuous: false })\n      });\n    }\n  };\n\n  const handleRecordingTimeout = () => {\n    timeoutId.current = window.setTimeout(() => {\n      setIsRecording(false);\n      stopMediaStream();\n      stopRecording({ exportWAV: false });\n    }, timeout);\n  };\n\n  const handleBlobToBase64 = ({\n    blob,\n    continuous\n  }: {\n    blob: Blob;\n    continuous: boolean;\n  }) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(blob);\n\n    reader.onloadend = async () => {\n      const base64data = reader.result as string;\n\n      let sampleRate = audioContextRef.current?.sampleRate;\n\n      // Google only accepts max 48000 sample rate: if\n      // greater recorder js will down-sample to 48000\n      if (sampleRate && sampleRate > 48000) {\n        sampleRate = 48000;\n      }\n\n      const audio = { content: '' };\n\n      const config: GoogleCloudRecognitionConfig = {\n        encoding: 'LINEAR16',\n        languageCode: 'en-US',\n        sampleRateHertz: sampleRate,\n        ...googleCloudRecognitionConfig\n      };\n\n      const data = {\n        config,\n        audio\n      };\n\n      // Gets raw base 64 string data\n      audio.content = base64data.substr(base64data.indexOf(',') + 1);\n\n      const googleCloudRes = await fetch(\n        `https://speech.googleapis.com/v1/speech:recognize?key=${googleApiKey}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(data)\n        }\n      );\n\n      const googleCloudJson = await googleCloudRes.json();\n\n      // Update results state with transcribed text\n      if (googleCloudJson.results?.length > 0) {\n        const { transcript } = googleCloudJson.results[0].alternatives[0];\n\n        setLegacyResults((prevResults) => [...prevResults, transcript]);\n\n        setResults((prevResults) => [\n          ...prevResults,\n          {\n            speechBlob: blob,\n            transcript,\n            timestamp: Math.floor(Date.now() / 1000)\n          }\n        ]);\n      }\n\n      if (continuous) {\n        startSpeechToText();\n      } else {\n        stopMediaStream();\n        setIsRecording(false);\n      }\n    };\n  };\n\n  const stopMediaStream = () => {\n    mediaStream.current?.getAudioTracks()[0].stop();\n  };\n\n  return {\n    error,\n    interimResult,\n    isRecording,\n    results: useLegacyResults ? legacyResults : results,\n    setResults,\n    startSpeechToText,\n    stopSpeechToText\n  };\n}\n","export default __webpack_public_path__ + \"static/media/mic.b386a135.svg\";","import React from 'react';\n\nimport useSpeechToText, { ResultType } from './Hooks';\n\n// @ts-ignore\nimport micIcon from './mic.svg';\n\nimport './App.css';\n\nexport default function App() {\n  const {\n    error,\n    interimResult,\n    isRecording,\n    results,\n    startSpeechToText,\n    stopSpeechToText\n  } = useSpeechToText({\n    continuous: true,\n    crossBrowser: false,\n    googleApiKey: process.env.REACT_APP_API_KEY,\n    speechRecognitionProperties: { interimResults: true, lang: 'en-US' },\n    useLegacyResults: false\n  });\n\n  if (error) {\n    return (\n      <div\n        style={{\n          maxWidth: '600px',\n          margin: '100px auto',\n          textAlign: 'center'\n        }}\n      >\n        <p>\n          {error}\n          <span style={{ fontSize: '3rem' }}>ü§∑‚Äç</span>\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      style={{\n        maxWidth: '600px',\n        margin: '100px auto',\n        textAlign: 'center'\n      }}\n    >\n      <h1>Recording: {isRecording.toString()}</h1>\n      <button onClick={isRecording ? stopSpeechToText : startSpeechToText}>\n        <span>{isRecording ? 'Stop Recording' : 'Start Recording'}</span>\n        <img data-recording={isRecording} src={micIcon} alt=\"\" />\n      </button>\n      <ul>\n        {(results as ResultType[]).map((result) => (\n          <li key={result.timestamp}>{result.transcript}</li>\n        ))}\n        {interimResult && <li>{interimResult}</li>}\n      </ul>\n    </div>\n  );\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}